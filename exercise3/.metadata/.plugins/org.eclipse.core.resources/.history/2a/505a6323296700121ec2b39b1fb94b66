import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.RenderingHints;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Random;

import javax.swing.JPanel;

public class DrawingArea extends JPanel {
	private Collection<DataPoint> trainingSet;
	private Collection<DataPoint> testSet;
	private double minX, maxX, minY, maxY;
	
	private static Color[] colors = new Color[]{new Color(230,0,0),//red
												new Color(0,0,230),//blue
												new Color(0,220,0),//green
												new Color(102,0,102),//violet
												new Color(255,153,0),//orange
												new Color(255,255,100)//beige
												};
	private HashMap<Integer,Color> classColorMap = new HashMap<Integer, Color>();
	private int pointRadius = 3;

	@Override
	protected void paintComponent(Graphics graphics) {
		super.paintComponent(graphics);
		this.setMinMaxCoordinates(this.trainingSet, this.testSet);
		Graphics2D g = (Graphics2D) graphics;
		g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
				RenderingHints.VALUE_ANTIALIAS_ON);
		int diameter = 2*this.pointRadius;
		if (trainingSet != null) {
			Point currentPoint;
			for (DataPoint dataPoint : trainingSet) {
				g.setColor(this.classColorMap.get(dataPoint.getClassification()));
				currentPoint = this.scale(dataPoint);
				g.fillOval(currentPoint.x, currentPoint.y, diameter, diameter);
			}
		}
	}

	public void setTrainingSet(DataSet dataSet) {
		if (dataSet == null || dataSet.dataPoints == null
				|| dataSet.dataPoints.isEmpty())
			return;
		this.trainingSet = dataSet.getAllDataPoints();
		this.initColorMap(this.trainingSet);
	}

	private void setMinMaxCoordinates(Collection<DataPoint> trainingPoints, Collection<DataPoint> testPoints) {
		Collection<DataPoint> dataPoints = new LinkedList<DataPoint>();
		dataPoints.addAll(trainingPoints);
		dataPoints.addAll(testPoints);
		minX = maxX = dataPoints.iterator().next().getX();
		minY = maxY = dataPoints.iterator().next().getY();
		
		for (DataPoint dataPoint : dataPoints) {
			if (dataPoint.getX() < minX) {
				minX = dataPoint.getX();
			}
			if (dataPoint.getX() > maxX) {
				maxX = dataPoint.getX();
			}
			if (dataPoint.getY() < minY) {
				minY = dataPoint.getY();
			}
			if (dataPoint.getY() > maxY) {
				maxY = dataPoint.getY();
			}
		}
	}
	
	private void initColorMap(Collection<DataPoint> dataPoints){
		int i=0;
		for (DataPoint dataPoint : dataPoints) {
			if(!this.classColorMap.containsKey(dataPoint.getClassification())){
				if(i<colors.length){
					this.classColorMap.put(dataPoint.getClassification(), colors[i]);
					i++;
				}else{
					this.classColorMap.put(dataPoint.getClassification(), new Color(new Random().nextInt()));
				}
			}
		}
	}

	public void paintDataSet(DataSet dataSet) {
		this.setTrainingSet(dataSet);
		this.repaint();
	}

	public Point scale(DataPoint dataPoint){
		Point scaledPoint = new Point();
		int border = 1;
		double scaleX = (this.getSize().getWidth()-2*this.pointRadius-2*border)/(this.maxX - this.minX);
		double scaleY = (this.getSize().getHeight()-2*this.pointRadius-2*border)/(this.maxY - this.minY);
		scaledPoint.x = this.pointRadius + border + (int)((dataPoint.getX()-this.minX) * scaleX - this.pointRadius);
		scaledPoint.y = this.pointRadius + border + (int)((dataPoint.getY()-this.minY) * scaleY - this.pointRadius);
		System.out.println("Scaled (" + Double.toString(dataPoint.getX()) + "," + Double.toString(dataPoint.getY()) + ") to (" + scaledPoint.x + "," + scaledPoint.y + ")");
		return scaledPoint;
	}
}
